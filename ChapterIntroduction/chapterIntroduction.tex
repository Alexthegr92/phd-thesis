\chapter{Introduction}

\section{Overview}

%Physics is important for games, it is used for...
Video games rely on real-time physics engines to provide realistic environments. This is noticeable in 3D gaming where players expect fast paced interaction. This requirement has produced significant commercial activity resulting in physics engines for real-time simulation for rigid body dynamics. Although realism is convincing, a degree of mathematical accuracy is usually sacrificed (causing error) in order to attain real-time delivery within constrained resource settings. However, with significant commercial effort, the mathematical error has reduced over the years and commercial game engines are finding their use in other industries (e.g.,  \cite{Xu2017, Lu2017, Shah2018}).

Combining physics engines with game engines (e.g., Unity, Unreal), presents a cost-efficient development platform for developing realistic environments. These gaming environments may be presented to geographically distant players using server-side scalable technologies. This allows scalable gaming platforms, presenting players with large online worlds to explore whilst maintaining the visually highly realistic environments generated by the player's local machine. Research into delivering scalability in such online worlds is focused on balancing real-time and consistency issues for enabling player-player interaction. The evolution of such research can be traced back to the earliest work on game area subdivision \cite{Npsnet} through player-focused game area sub-division (e.g., \cite{Morgan2005InterestManagement, Greenhalgh}) and eventually to the many commercial cloud based solutions as described by \cite{iCloudAccess}.

Scaling and more complex games is a selling point.
The problem of scalable player-player interaction is not a solved problem, as the numerous interaction possibilities across gaming genres and the latency in networks provides many different possible bespoke solutions. Player interaction can be measured in milliseconds, which current networking technology cannot model for all gaming genres in a scalable manner without giving rise to inconsistency. Therefore, the notion of trying to model real-time physics, which requires solvers working in iterations measured in microseconds, would be considered a near impossible task. However, achieving this would allow the physics engine element of the gaming console to be transplanted to the server-side (cloud), freeing up resources for game-play and rendering on a player's local machine.
Traditionally real-time simulations are confined to a single machine, including real-time physics. 
Recent cloud technology has made available, lower cost, low-latency, high-performance, including GPU-enabled machines. This means, real-time simulations can now run in the cloud as well as being economically viable. It is possible to rapidly provision resources on demand, allowing for fast scaling up and down of resources as needed.

Recent developments have demonstrated the importance of software defined networks (SDN) for presenting timely cloud solutions \cite{Wang, Kumar}. The SDN manages the distribution of messages across servers in the most economical way possible (e.g., resource usage). The fact that SDNs can produce timely messaging across tightly coupled server-side deployments (the cloud) suggests the possibility that timely requirements for scalable physics delivery can be fulfilled.

The potential uses of scaling real-time physics simulations are vast. (Large world, physics based games, game relying on physics queries (AI)). Scaling real-time physics is useful not only for games, but large-scale simulations where querying or simulating the physical state of the world is heavily used, e.g. large-scale multi-agent AI, such as city simulations, military simulations. 

Server authoritative physics would also allow over the network multiplayer games to rely heavily on physical elements. In games, only a limited part of the game is simulated on the server side and not physics, with focus on player-player interaction and not player-environment (physics) interaction, as this is a limit of existing technology. 
Synchronising physics states between players and servers is not possible due to latency, two players will have different views of the physical state of the world, based on their latency, interactions from those player's with the physical state will cause divergence, which may not be possible to converge. This is normally worked around by not having physics affect gameplay and using kinematic sequences, ensuring determinism. A single physics simulation, resolves these problems of multiple physics states, which have to be synchronised and lead to divergent physics states. 

Simulating the physical state of the world entirely in the cloud frees up resources on the user's machine allowing for more processing time to be spent on other systems, such as graphics, AI etc. Alternatively, simulating physics in the cloud could be combined with streamed gaming.

Streamed gaming is an active area of research (e.g., \cite{GARCIAVALLS}), where the game is executed on the server-side, the graphical output is streamed to a remote player and input is sent from the player to the server-side (e.g., \cite{PSNOW, NVidiaGameStream}). The existence of such services suggests the possibility of real-time interaction for all gaming genres across cloud infrastructures. 

%Streamed gaming is an active area of research, where the game is run entirely in the cloud, with the graphical output streamed to the player. 
Streamed gaming reduces the computing power requirements on player hardware, even allowing gaming on mobile devices with graphical quality beyond what would be possible if the game were running entirely the device. If the physics simulation is co-located with the graphics streaming servers (with very low-latency), the problem of latency between player's view of the physics simulation and actual state is resolved, allowing for a better shared view of the physics state.

It therefore is the next logical step to start breaking apart the different systems of the game into their own 'containers', allowing for independent scaling and resource provision management. Our problem is concentrated on distributing the physics engine element of game engines across the server-side while maintaining the real-time streamed service to players.
Using the recent developments in cloud technology, we explore the possibility of using this on-demand scaling, to scale up real-time physics simulations.

In the context of current research, we can place ourselves at the juncture of balancing physics calculations across servers in the cloud for game streaming services. This should provide improved economic use of resources, as current game streaming services simply mimic the machine requirements of the player without distributing any of the component parts of the gaming engine. In addition, streamed games may benefit from increased numbers of artefacts (way beyond what is currently possible in a player's machine) as other servers may be utilised to solve the physics problems.

To achieve our research goal while remaining relevant to current state-of-the-art physics simulations, this study uses PhysX (from Nvidia) as the physics engine \cite{PhysX}. This ensures a simulation equal in detail to commercial video game titles. The challenge is to deploy instances of PhysX into a cloud infrastructure (on multiple servers) and allow objects within a simulation to be seamlessly passed across PhysX instances. We construct messaging services to enable PhysX instances on different servers to communicate and divide the simulation geographically across such servers. The challenge of this research is ensuring real-time fidelity can be satisfied when objects migrate across PhysX instances (from server to server). This problem of object migration is complicated by the possibility of object interaction occurring during such migration. Considering the assumption of commercial level fidelities of fast paced objects and frame rates of 60 frames per-second, any anomalous behaviour of objects during migration would be easily discernible to a player. 


\section{Purpose of Study}
The purpose of this study is to test the following hypotheses: "Can scalable real-time physics be achieved?" and "Can real-time physics simulations remain correct when scaled?". This study is intended, for the first time in an academic setting, to demonstrate scalable real-time physics. 
The requirements needed for a solution to scalable real-time physics are discussed and several different approaches are considered before justifying the approach taken in this study's proposed solution. 
A prototype solution to scalable real-time physics, Aura Projection (AP), has been developed for this study. AP has provided a means of testing the above hypotheses through experiments that have been put forward by this study.

\section{Outline}
The following section provides an outline for this study:
2. Background and Related Work:
\begin{itemize}
	%Context
	\item Real-time physics engines overview. We introduce the reader to the topic of physics simulations and we compare real-time with non-real-time physics simulations. We define terms, workings, important and relevant aspects, e.g. body types, uses in games and simulations, typical scales and performance of real-time simulations and performance budget in real-time applications.
	\item Scalable Non-Real Time Physics. We discuss previous work and applications of scalable non-real time physics and how those techniques are not suitable for use in real-time physics simulations.
	\item Online gaming. We discuss the wider topic of online gaming (client-hosted, P2P, server), challenges of latency, security/cheating and computational limits. Also some details of online gaming servers are discussed, specifically, typical server frame-times and network tick updates. 
	\item Physics in online gaming (and the lack of, due to the challenges faced).
	%Relevant Related Work
	\item Graph-partitioning. When it comes to spatially-partitioning a simulation, the problem is essentially a graph partitioning problem, where objects are nodes and if thereâ€™s a possible interaction, an edge exists. Useful for terms, comparisons with and future work on load-balancing will heavily involve this.
	\item Distributed virtual environments. We look at existing ways of distributing game worlds and previous work carried out on these approaches. These fall into two categories, migratory (approach used by AP) and non-migratory. The studies found non-migratory to be the better solution when focusing on player-player interaction and we will discuss why migratory is the better solution for physics body-physics body interaction. Important concepts such as interest management are introduced to the reader.
	\item Distributed Real-time Physics. We will discuss previous work looking specifically at distributing real-time physics and how AP differs from these approaches.
	\item Cloud Computing. We discuss the wider context of cloud computing, how AP is deployed on the cloud and also specifically conditions that affect AP in the cloud, i.e. latency and packet-loss
	%Applications
	\item Scientific and Engineering simulations. Real-time simulations are being used more in scientific research, however these are limited to what can be achieved on a single machine. AP allows real-time physics simulations to be scaled, enabling large or complex simulations, that otherwise wouldn't have been able, to run in real-time.
	\item Containerisation of Game Engines. Game engines, generally, currently run as one single application, including graphics, physics, AI etc. (with the exception of databases for user data). AP separates out the physics element into its own container, much like many modern systems are splitting up different aspects of systems into their own containers, for example web applications. This containerisation of physics, means, physics can be elastically scaled independently from other systems such as graphics, along with other advantages of modularity.
	\item Streamed Gaming. The main foreseeable application of AP is Streamed Gaming, with the use of large multiplayer worlds, that are persistent and scalable with dedicated and elastic physics nodes. Physics is no longer limited to what can be simulated on a single machine and co-located render nodes solves the issue of higher latencies between the render node and physics simulation, the main problem with the use of physics in online gaming.
\end{itemize}

3. Problem Definition:
\begin{itemize}
	\item Solution Requirements. We discuss what is required of a solution to scalable real-time physics.
	\item Naive approach. How would a naive approach behave and what problems occur.
	\item Considered Solutions. We consider a number of solutions to scalable real-time physics.
	\item Proposed Solution. We look at in more detail how our solution works and justification for its choice.
	\item Aura Calculation. A detailed look at the important aspect of AP, the aura calculation.
	\item Sub-optimal object hosting. We look at one the predicted challenge with AP, sub-optimal object hosting and discuss a solution which can be addressed in future work.
	\item Thrashing. A further predicted challenge with AP, this consists of two types of thrashing, two and three object thrashing, three object thrashing has been solved in this implementation of AP and we discuss solutions to two object thrashing.
	\item Islands. A solved challenge with AP, here we discuss our solution.
	\item Corner Case. AP has been discussed in terms of a single boundary between two servers up to this point, but in order for a general solution to be achieved, AP must be able to support boundaries between three or more servers, such as at corners.
\end{itemize}

4. Implementation
\begin{itemize}
	\item System Architecture. We discuss how the system is organised. How AP interacts with PhysX. How messages are exchanged between servers using RakNet and how the client communicates with the servers, enabling interaction.
	\item Algorithms. The algorithms used by AP are defined with pseudo-code and explained.
	% The visualiser
	\item The Visualiser. We discuss the features and implementation of the visualiser, including server and client created replicas, static objects and interactivity. The challenges of multiple servers are explained and our solutions justified. Screenshots from demo scenes have been included.
	%Client connects to multiple servers, objects from all servers are replicated on the visualiser. Supports server-created objects, limited to pre-defined basic objects (cuboid, sphere \& capsule) and a different material per server is used to identify owning server. Also supports arbitrary client-created objects, objects with any mesh, that the server does not need to know about until it is created on the client, the client communicates all data required to create the physical object on the server, the server then simulates the created object and the object's state (position, rotation) is then replicated on the client. Client-created static objects are also supported. The visualiser also allows for interactivity, the creation of server-created objects can be triggered from the client, as well as allowing the user to reset or change scenes that are being simulated on the server.
	%Can discuss better ways of dealing with server-created migrating objects, the lack of functional client-created object migration, scene-serialisation, interest management, mesh deformation
\end{itemize}

5. Experiments and Results
\begin{itemize}
	\item Scalability Experiments. We describe and justify the design of experiments designed to address the first question of this thesis: Can scalable real-time physics simulations be achieved? AP's performance is measured with different numbers of servers in different topologies. The results of which, are analysed and discussed.
	\item Collisions Correctness Experiments. Collisions correctness is defined and erroneous collisions are classified. We describe and justify the design of experiments designed to address the second question of this thesis: Can real-time physics simulations remain correct when scaled? The correctness of collisions are measured using different conditions and tolerances. The results of which, are analysed and discussed.
\end{itemize}

6. Conclusion and Future Work
\begin{itemize}
	\item Conclusion. The results and findings of our experiments are used to answer the questions asked in this thesis: "Can scalable real-time physics simulations be achieved?" and "Can real-time physics simulations remain correct when scaled?"
	\item Future Work. We discuss future questions regarding scalable real-time physics and future implementation plans for AP.
\end{itemize}
