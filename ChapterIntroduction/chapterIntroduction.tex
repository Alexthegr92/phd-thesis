\chapter{Introduction}
%TODO: Introduction paragraph?
\section{Real-Time Physics}

Physics has been a part of video games for almost as long as video games have existed \cite{millington2007game}. Real-time physics is necessary to provide realistic 2D and 3D environments to players as it allows players to interact with the simulated environment. For example, moving crates around, simulating the flight of a plane or the ballistics of a bullet. Physics engines are responsible for all of the calculations required to simulate physics. Physics engines for games aim to achieve `realism', but sacrifice accuracy in order to achieve real-time speeds. Recently, the mathematical error from commercial physics engines has been reduced and physics engines are finding use in other simulations besides video games (\cite{Xu2017, Lu2017, Shah2018}).

%\section{Distributed Real-Time Physics}
%Physics is important for games, it is used for...
%Video games rely on real-time physics engines to provide realistic environments. This is noticeable in 3D gaming where players expect fast paced interaction. This requirement has produced significant commercial activity resulting in physics engines for real-time simulation for rigid body dynamics. Although realism is convincing, a degree of mathematical accuracy is usually sacrificed (causing error) in order to attain real-time delivery within constrained resource settings. However, with significant commercial effort, the mathematical error has reduced over the years and commercial game engines are finding their use in other industries (e.g.,  \cite{Xu2017, Lu2017, Shah2018}).

%Combining physics engines with game engines (e.g., Unity, Unreal), presents a cost-efficient development platform for developing realistic environments. These gaming environments may be presented to geographically distant players using server-side scalable technologies. This allows scalable gaming platforms, presenting players with large online worlds to explore whilst maintaining the visually highly realistic environments generated by the player's local machine. 

\section{Scalable Games and Simulations}
Scaling and more complex games are a selling point. This has been demonstrated by games such as EVE Aether Wars \cite{AetherEngine} and \cite{WorldsAd48:online}, built using HadeanOS and SpatialOS respectively. HadeanOS and SpatialOS both provide attempts at distributing physics by allowing physical interactions across servers. Despite the growing commercial interest in this area, there is no academic literature into the challenges and solutions of distributed real-time physics and HadeanOS and SpatialOS are both proprietary software.

Research into delivering scalability in such online worlds is focused on balancing real-time and consistency issues for enabling player-player interaction. The evolution of such research can be traced back to the earliest work on game area subdivision \cite{Npsnet} through player-focused game area sub-division (\cite{Morgan2005InterestManagement, Greenhalgh}) and eventually to the many commercial cloud based solutions as described by \cite{iCloudAccess}.

Traditionally real-time simulations are confined to a single machine, including real-time physics. 
Recent cloud technology has made available, lower cost, low-latency and high-performance machines, including GPU-enabled instances. This means, real-time simulations can now run in the cloud as well as being economically viable. It is possible to rapidly provision resources on demand, allowing for fast scaling up and down of resources as needed.

Physics is the most challenging problem facing distributing games engines. Handling player-player interaction between servers, which is still not a solved problem, requires response times in the order of hundreds of milliseconds and still leads to inconsistencies in the game world. Real-time physics solvers work in iterations normally measured in the order of less than 10 milliseconds. Although this poses a significant challenge, achieving distributed real-time physics would allow the physics engine component of the game engine to be elastically scaled, meaning the physics engine is no longer limited in scale and complexity to what would be achievable on a single machine.

%The problem of scalable player-player interaction is not a solved problem, as the numerous interaction possibilities across gaming genres and the latency in networks provides many different possible bespoke solutions. Player interaction can be measured in milliseconds, which current networking technology cannot model for all gaming genres in a scalable manner without giving rise to inconsistency. Therefore, the notion of trying to model real-time physics, which requires solvers working in iterations measured in microseconds, would be considered a near impossible task. However, achieving this would allow the physics engine element of the gaming console to be transplanted to the server-side (cloud), freeing up resources for game-play and rendering on a player's local machine.

The potential uses of scaling real-time physics simulations are vast. (Large world, physics based games, game relying on physics queries (AI)). Scaling real-time physics is useful not only for games, but large-scale simulations where querying or simulating the physical state of the world is heavily used, e.g. large-scale multi-agent AI, such as city simulations, military simulations. 

Server authoritative physics would also allow over the network multiplayer games to rely heavily on physical elements. In games, only a limited part of the game is simulated on the server side and not physics, with focus on player-player interaction and not player-environment (physics) interaction, as this is a limit of existing technology. 
Synchronising physics states between players and servers is not possible due to latency, two players will have different views of the physical state of the world, based on their latency, interactions from those player's with the physical state will cause divergence, which may not be possible to converge. This is normally worked around by not having physics affect gameplay and using kinematic sequences, ensuring determinism. A single physics simulation, resolves these problems of multiple physics states, which have to be synchronised and lead to divergent physics states. 

Simulating the physical state of the world entirely in the cloud frees up resources on the user's machine allowing for more processing time to be spent on other systems, such as graphics and AI. Alternatively, simulating physics in the cloud could be combined with streamed gaming.

\section{Streamed Gaming}
Streamed gaming is an active area of research (e.g., \cite{GARCIAVALLS}), where the game is executed on the server-side, the graphical output is streamed to a remote player and input is sent from the player to the server-side.
Streamed gaming reduces the computing power requirements on player hardware, even allowing gaming on mobile devices with graphical quality beyond what would be possible if the game were running entirely on the device \cite{CloudGamingArchPerf}. In addition, this removes the need for players to continuously upgrade their hardware \cite{LatencyoOfCloudGamingSystems}. 

The most difficult challenge in streamed gaming is the quality of experience of games, as the experience is significantly impacted by delay\cite{StormInCloudGaming}. The effect on quality depends upon the time of game, for example low-latency games like first person shooters require response times as little as 100ms, whereas, real-time strategy games can have acceptable response times of up to 1000ms \cite{CloudGamingArchPerf}. Recent advances in cloud gaming, including the use of edge cloud game servers, have enabled the cloud to be utilised to deliver low-latency gaming \cite{TimelyCloudGaming}.

Examples of streamed gaming services include Sony's PSNOW \cite{PSNOW}, NVidia's GameStream \cite{NVidiaGameStream} and Google's Stadia \cite{Stadia}. The existence of such services suggests the possibility of real-time interaction for all gaming genres across cloud infrastructures.

%TODO: How can scalable real-time physics be combined with streamed gaming?

%Recent developments have demonstrated the importance of software defined networks (SDN) for presenting timely cloud solutions \cite{Wang, Kumar}. The SDN manages the distribution of messages across servers in the most economical way possible (e.g., resource usage). The fact that SDNs can produce timely messaging across tightly coupled server-side deployments (the cloud) suggests the possibility that timely requirements for scalable physics delivery can be fulfilled.

%If the physics simulation is co-located with the graphics streaming servers (with very low-latency), the problem of latency between player's view of the physics simulation and actual state is resolved, allowing for a better shared view of the physics state.

\section{Summary}
Real-time physics is an integral part of games technology. There has been recent commercial interest in using cloud computing to scale up games, including the most challenging aspect, the physics simulation component. In addition, scaling up physics simulations provides an increase in possible size and complexity of virtual worlds used in online games (a greater number of simulated entities and an increase in systems that are expensive to simulate). If achieved, real-time physics engines can be scaled beyond what is currently possible on a player's machine or single server and provides elastic scaling of resources for use in streamed gaming. Despite the recent interest and advantages, no academic literature has been produced addressing scalable real-time physics.

\section{Purpose of Study}
The purpose of this study is to test the following hypotheses: "Can scalable real-time physics be achieved?" and "Can real-time physics simulations remain correct when scaled?". This study is intended, for the first time in an academic setting, to demonstrate scalable real-time physics. 
The requirements needed for a solution to scalable real-time physics are discussed and several different approaches are considered before justifying the approach taken in this study's proposed solution. 
A prototype solution to scalable real-time physics, Aura Projection (AP), has been developed for this study and has provided a means of testing the above hypotheses through experiments that have been put forward by this study.
AP uses PhysX (from Nvidia) as the physics engine \cite{PhysX}, providing a simulation with equal accuracy and behaviour to commercial video games. The main challenge addressed by AP is to deploy multiple instances of PhysX in the cloud, across multiple servers and through the use of messaging services, while allowing objects within the physics simulation to be seamlessly passed and interact across server-region boundaries. Achieving interactions of objects across server-region boundaries is a complex problem to solve and small errors can easily be discerned by the player in the form of `jitter'. In some cases errors can lead to great anomalies in behaviour and results in servers having significantly different states for the same set of objects.

\section{Outline}
%TODO: Make sure this is up to date
The following section provides an outline for this study:
2. Background and Related Work:
\begin{itemize}
	%Context
	\item Real-time physics engines overview. The reader is introduced to the topic of physics simulations and real-time and non-real-time physics simulations are compared. The following are defined: terms; workings; important and relevant aspects, e.g. body types; uses in games and simulations; typical scales and performance of real-time simulations; and performance budget in real-time applications.
	\item Scalable Non-Real Time Physics. Previous work and applications of scalable non-real time physics and how those techniques are not suitable for use in real-time physics simulations are discussed.
	\item Online gaming. The wider topic of online gaming is discussed, including the main challenges faced and typical architectures used (client-sever, peer-to-peer, distributed servers). Important aspects to this study's work are also discussed, specifically, typical server frame-times and network tick updates, delta-encoding and protocols. 
	\item RakNet. A brief overview is given of the important features of RakNet, the network library used in this study's implementation (AP).
	\item Consistency in Real-Time Physics. The challenges of consistency in physics are addressed. The client-side compensation technique of dead-reckoning is discussed and how it creates consistency problems.
	%Relevant Related Work
%	\item Graph-partitioning. When it comes to spatially-partitioning a simulation, the problem is essentially a graph partitioning problem, where objects are nodes and if there is a possible interaction, an edge exists. Useful for terms, comparisons with and future work on load-balancing will heavily involve this.
	\item Distributed virtual environments. Existing ways of distributing game worlds are reviewed and previous work carried out on these approaches. These fall into two categories, migratory (approach used by AP) and non-migratory. The studies found non-migratory to be the better solution when focusing on player-player interaction and why migratory is the better solution for physics body-physics body interaction will be discussed. Important concepts such as interest management are introduced to the reader.
	\item Distributed Real-time Physics. Previous work looking specifically at distributing real-time physics will be reviewed and how AP differs from these approaches.
	\item Cloud Computing. The wider context of cloud computing will be discussed and how AP is deployed on the cloud and also specifically conditions that affect AP in the cloud, i.e. latency and packet-loss
	%Applications
	\item Real-time Physics for Scalable Simulations. Real-time simulations are being used more in scientific research, however these are limited to what can be achieved on a single machine. AP allows real-time physics simulations to be scaled, enabling large or complex simulations that otherwise wouldn't have been able, to run in real-time.
	\item Microservices for Game Engines. Game engines, generally, currently run as one single application (monolith), including graphics, physics, AI etc. (with the exception of databases for user data). AP separates out the physics element into its own microservice, much like many modern systems are splitting up different aspects of systems into their own microservices, for example web applications. This separation of physics into a microservice means physics can be elastically scaled independently from other systems such as graphics, along with other advantages of modularity.
	\item Streamed Gaming. The main foreseeable application of AP is Streamed Gaming, with the use of large multiplayer worlds, that are persistent and scalable with dedicated and elastic physics nodes. Physics is no longer limited to what can be simulated on a single machine and co-located render nodes solves the issue of higher latencies between the render node and physics simulation, the main problem with the use of physics in online gaming.
\end{itemize}

3. Problem Definition:
\begin{itemize}
	\item Solution Requirements. What is required of a solution to scalable real-time physics is discussed.
	\item Naive approach. How would a naive approach behave and what problems occur.
	\item Considered Solutions. A number of solutions to scalable real-time physics are considered.
	\item Proposed Solution. How AP works is looked at in more detail and justifications are made for its choice.
	\item Aura Calculation. A detailed look at the important aspect of AP - the aura calculation.
	\item Sub-optimal object hosting. One the predicted challenge with AP is looked at: sub-optimal object hosting and a solution which can be addressed in future work is discussed.
	\item Thrashing. A further predicted challenge with AP, this consists of two types of thrashing, two and three object thrashing, three object thrashing has been solved in this implementation of AP and solutions to two object thrashing are discussed.
	\item Islands. A solved challenge with AP. AP's solution to islands is discussed.
	\item Corner Case. AP has been discussed in terms of a single boundary between two servers up to this point, but in order for a general solution to be achieved, AP must be able to support boundaries between three or more servers, such as at corners.
\end{itemize}

4. Implementation
\begin{itemize}
	\item System Architecture. How the deployment system is structured. How AP interacts with PhysX. How messages are exchanged between servers using RakNet and how the client communicates with the servers, enabling interaction.
	\item Aura Implementation. A high-level overview of how the auras are implemented in AP.
	\item Algorithms. The algorithms used by AP are defined with pseudo-code and explained.
	\item FSM. A finite-state-machine representation of the state of an object in AP is presented.
	% The visualiser
	\item The Visualiser. The features and implementation of the visualiser are discussed, including server and client created replicas, static objects and interactivity. The challenges of multiple servers are explained and the solutions used are justified. Screenshots from demo scenes have been included.
	%Client connects to multiple servers, objects from all servers are replicated on the visualiser. Supports server-created objects, limited to pre-defined basic objects (cuboid, sphere \& capsule) and a different material per server is used to identify owning server. Also supports arbitrary client-created objects, objects with any mesh, that the server does not need to know about until it is created on the client, the client communicates all data required to create the physical object on the server, the server then simulates the created object and the object's state (position, rotation) is then replicated on the client. Client-created static objects are also supported. The visualiser also allows for interactivity, the creation of server-created objects can be triggered from the client, as well as allowing the user to reset or change scenes that are being simulated on the server.
	%Can discuss better ways of dealing with server-created migrating objects, the lack of functional client-created object migration, scene-serialisation, interest management, mesh deformation
\end{itemize}

5. Experiments and Results
\begin{itemize}
	\item Scalability Experiments. The design of experiments designed to address the first question of this thesis: "Can scalable real-time physics simulations be achieved?" are described and justified. AP's performance is measured with different numbers of servers in different topologies. The results of which, are analysed and discussed.
	\item Collisions Correctness Experiments. Collisions correctness is defined and erroneous collisions are classified. The design of experiments designed to address the second question of this thesis: "Can real-time physics simulations remain correct when scaled?" are described and justified. The correctness of collisions are measured using different conditions and tolerances. The results of which, are analysed and discussed.
\end{itemize}

6. Conclusion and Future Work
\begin{itemize}
	\item Conclusion. The results and findings of this study's experiments are used to answer the questions asked in this thesis: "Can scalable real-time physics simulations be achieved?" and "Can real-time physics simulations remain correct when scaled?"
	\item Future Work. Future possible research into scalable real-time physics is discussed and future implementation and experimentation plans for AP are described.
\end{itemize}
